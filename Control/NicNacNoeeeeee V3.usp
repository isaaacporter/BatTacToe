#CATEGORY "46" "IPorter" // Custom
/*******************************************************************************************
  SIMPL+ Module Information
  (Fill in comments below)
*******************************************************************************************/
/*
Dealer Name:
System Name:
System Number:
Programmer: Isaac Porter, Leanna Lincoln, Caleb Hackett
Comments:
*/

#DEFAULT_VOLATILE
#ENABLE_STACK_CHECKING
#ENABLE_TRACE
#DEFINE_CONSTANT GRIDSIZE 3
#DEFINE_CONSTANT SQGRIDSIZE 9


/*******************************************************************************************
  DIGITAL, ANALOG and SERIAL INPUTS and OUTPUTS
  (Uncomment and declare inputs and outputs as needed)
*******************************************************************************************/
            DIGITAL_INPUT END_GAME;												
            DIGITAL_INPUT NEXT_GAME;
            DIGITAL_INPUT BATMAN_FIRST;
            DIGITAL_INPUT JOKER_FIRST;
            DIGITAL_INPUT ONE_PLAYERS;
			DIGITAL_INPUT TWO_PLAYERS;
			DIGITAL_INPUT EASY_GAME;
			DIGITAL_INPUT MEDIUM_GAME;
			DIGITAL_INPUT HARD_GAME;
			DIGITAL_INPUT IMPOSSIBLE_GAME;
			DIGITAL_INPUT SET_GRID[SQGRIDSIZE];


            DIGITAL_OUTPUT END_GAME_BATMAN;
            DIGITAL_OUTPUT END_GAME_JOKER;
            DIGITAL_OUTPUT END_GAME_CATWOMAN;
			DIGITAL_OUTPUT COUNT_ACTIVE;
			DIGITAL_OUTPUT CHOOSE_CHARACTER;
			DIGITAL_OUTPUT CHOOSE_HOW_MANY;
			DIGITAL_OUTPUT CHOOSE_DIFFICULTY;
			DIGITAL_OUTPUT HOW_MANY_PLAYERS;
		                
			ANALOG_OUTPUT CURRENTPLAYER;
			ANALOG_OUTPUT WHO_WON;
			ANALOG_OUTPUT WHO_LOST;
			ANALOG_OUTPUT WINNER_COUNT;
			ANALOG_OUTPUT LOSER_COUNT;
            ANALOG_OUTPUT GRID[SQGRIDSIZE];
/*******************************************************************************************
  Parameter Properties
  (Uncomment and declare parameter properties as needed)
*******************************************************************************************/
/*******************************************************************************************
  Global Variables
  (Uncomment and declare global variables as needed)
  Note:  Be sure to initialize all declared STRING variables as needed
         For example, in Function Main: myString = "";
*******************************************************************************************/
   INTEGER 	BOARD[2][2],
           	OLDPLAYER,
           	LASTPLACEDROW,
          	LASTPLACEDCOLUMN,
		   	BATMAN_COUNT,
		    JOKER_COUNT,
			HOW_DIFFICULT,
			COUNTER
			IMPOSSIBLE_ACTIVE;
/*******************************************************************************************
  Functions
  (Add any additional functions here)
  Note:  Functions must be physically placed before the location in
         the code that calls them.
*******************************************************************************************/
Function SETBOARD()
{
            END_GAME_BATMAN = 0; 			// Mutes End Game Pop Up Screens
            END_GAME_JOKER = 0;
            END_GAME_CATWOMAN = 0;                     
}

Function RESET_COUNT()
{
			WHO_WON = 0;					// Mutes Winner Face in Corner
			WHO_LOST = 0; 					// Mutes Loser Face in Corner  	  	
			BATMAN_COUNT = 0;				// Resets BATMAN win total to 0
            JOKER_COUNT = 0;				// Resets JOKER win total to 0
			WINNER_COUNT = 0;				// Resets displayed winner count
			LOSER_COUNT = 0;				// Resets displayed loser count
			COUNT_ACTIVE = 0;				// Mutes counts displayed on screen 
  			CHOOSE_HOW_MANY = 1;			// Displays How Many Players on screen           
			CHOOSE_DIFFICULTY = 1;			// Displays Choose Difficulty on screen
  			CHOOSE_CHARACTER = 1;			// Displays choose character screen
			IMPOSSIBLE_ACTIVE = 0;			// Resets Impossible EASTER EGG
}

Function SWITCHPLAYER()
{
   			INTEGER TEMP;

    		TEMP = CURRENTPLAYER;
    		CURRENTPLAYER = OLDPLAYER;     	// Switches players from 1 to 4, or 4 to 1
   			OLDPLAYER = TEMP;
}

Function CLEAR_BOARD()
{
    		integer i,j;
            for (i = 0 to 2)
            {
                        for (j = 0 to 2)
                        {
                                    BOARD[i][j] = 0;               	// Sets every cell in BOARD to zero
                        }
            }
            SETBOARD();
}

Integer_Function GET_CELL_STATE(integer ROW, integer COL)
{
           if (BOARD[ROW][COL] = 1)                                 // If cell has 1 (BATMAN), return 1
            {
            return (1);
            }
            
            else if (BOARD[ROW][COL] = 4)                         	// If cell has 4 (JOKER), return 4
            {
            return (4);
            }
            else if (BOARD[ROW][COL] = 2)							// If cell has 2 (EGG), return 2
			{
			return(2);
			else return (0);                               			// Return empty cell

}
Function UPDATE_BOARD()
{
		integer i, rows, column;
        for (i = 1 to SQGRIDSIZE)
        {
         	column = (i - 1) % GRIDSIZE;
            rows = ((i - 1) - column) / GRIDSIZE;
            GRID[i] = GET_CELL_STATE(rows, column);
        }
}


Function SET_CELL_STATE(integer ROW, integer COL)
{
     	BOARD[ROW][COL] = CURRENTPLAYER;                     		// Sets BOARD to CURRENTPLAYER, 1 for BATMAN or 4 for JOKER
}
   
Integer_Function CHECK_IF_WIN()
{
        if
                        (  
                           BOARD[LASTPLACEDROW] [0]     = CURRENTPLAYER
                        && BOARD[LASTPLACEDROW] [1]     = CURRENTPLAYER
                        && BOARD[LASTPLACEDROW] [2]     = CURRENTPLAYER 

                        || BOARD[0] [LASTPLACEDCOLUMN]  = CURRENTPLAYER
                        && BOARD[1] [LASTPLACEDCOLUMN]  = CURRENTPLAYER
                        && BOARD[2] [LASTPLACEDCOLUMN]  = CURRENTPLAYER


                        || LASTPLACEDROW = LASTPLACEDCOLUMN            
                        && BOARD[0] [0]                 = CURRENTPLAYER
                        && BOARD[1] [1]                 = CURRENTPLAYER
                        && BOARD[2] [2]                 = CURRENTPLAYER

                        || LASTPLACEDROW + LASTPLACEDCOLUMN = 2 
                        && BOARD[0] [2]                 = CURRENTPLAYER
                        && BOARD[1] [1]                 = CURRENTPLAYER
                        && BOARD[2] [0]                 = CURRENTPLAYER
                        )
                        return(1);

                        else return (0);
                        
}

Integer_Function CHECK_IF_DRAW()
{	
integer x, y, z;
x = CURRENTPLAYER + OLDPLAYER;
y = CURRENTPLAYER + OLDPLAYER + OLDPLAYER;
z = CURRENTPLAYER + CURRENTPLAYER + OLDPLAYER;

IF(((BOARD[0][0]+BOARD[0][1]+BOARD[0][2] = x)||(BOARD[0][0]+BOARD[0][1]+BOARD[0][2] = y)||(BOARD[0][0]+BOARD[0][1]+BOARD[0][2] = z)) && ((BOARD[1][0]+BOARD[1][1]+BOARD[1][2] = x)||(BOARD[1][0]+BOARD[1][1]+BOARD[1][2] = y)||(BOARD[1][0]+BOARD[1][1]+BOARD[1][2] = z)) && ((BOARD[2][0]+BOARD[2][1]+BOARD[2][2] = x)||(BOARD[2][0]+BOARD[2][1]+BOARD[2][2] = y)||(BOARD[2][0]+BOARD[2][1]+BOARD[2][2] = z)) && ((BOARD[0][0]+BOARD[1][0]+BOARD[2][0] = x)||(BOARD[0][0]+BOARD[1][0]+BOARD[2][0] = y)||(BOARD[0][0]+BOARD[1][0]+BOARD[2][0] = z)) && ((BOARD[0][1]+BOARD[1][1]+BOARD[2][1] = x)||(BOARD[0][1]+BOARD[1][1]+BOARD[2][1] = y)||(BOARD[0][1]+BOARD[1][1]+BOARD[2][1] = z))
&& ((BOARD[0][2]+BOARD[1][2]+BOARD[2][2] = x)||(BOARD[0][2]+BOARD[1][2]+BOARD[2][2] = y)||(BOARD[0][2]+BOARD[1][2]+BOARD[2][2] = z)) && ((BOARD[0][0]+BOARD[1][1]+BOARD[2][2] = x)||(BOARD[0][0]+BOARD[1][1]+BOARD[2][2] = y)||(BOARD[0][0]+BOARD[1][1]+BOARD[2][2] = z)) && ((BOARD[0][2]+BOARD[1][1]+BOARD[2][0] = x)||(BOARD[0][2]+BOARD[1][1]+BOARD[2][0] = y)||(BOARD[0][2]+BOARD[1][1]+BOARD[2][0] = z)))											//Checking to see if there is a draw state in every row, column, and diagonal. 

    {
        RETURN(1);									// Return 1 if draw state is detected
    }
ELSE
    {
        RETURN(0);									// Return 0 if draw state is not detected
    }
		
}
Integer_Function CHECK_BOARD()
{           if (CHECK_IF_WIN() = 1)         

            return(CURRENTPLAYER);                   // Returns CURRENTPLAYER if they win
            
            else if (CHECK_IF_DRAW() = 1)
            return (10);                             // Returns 10 if draw
                        
            else return (0);                         // Reurns 0 if continue
}                                    

Integer_Function FINAL_CHECK()
{
		switch (CHECK_BOARD())
				{
					case(1):
					{
	             		BATMAN_COUNT = BATMAN_COUNT + 1;	// BATMAN Win Count Increases
						WINNER_COUNT = BATMAN_COUNT;		// BATMAN Win Count passed to WINNER COUNT
						LOSER_COUNT = JOKER_COUNT;			// JOKER Win Count passed to LOSER COUNT
						COUNT_ACTIVE = 1;					// Displays WINNER/LOSER COUNT
	              		END_GAME_BATMAN= 1;					// Displays BATMAN END GAME Screen
						WHO_WON = 1;						// WINNER IS BATMAN
						WHO_LOST = 4;						// LOSER IS JOKER
						return(1);
					}
	
	            
	     
	            	case(4):
	           	 	{
	             		JOKER_COUNT = JOKER_COUNT + 1;		// JOKER Win Count Increses
						WINNER_COUNT = JOKER_COUNT;			// JOKER Win Count passed to WINNER COUNT
						LOSER_COUNT = BATMAN_COUNT;			// BATMAN Win Count passed to LOSER COUNT
						COUNT_ACTIVE = 1;					// Displays WINNER/LOSER COUNT
	              		END_GAME_JOKER = 1;					// Displays JOKER END GAME Screen
              			WHO_WON = 4;						// WINNER IS JOKER
						WHO_LOST = 1;						// WINNER IS BATMAN
						return(1);
	            	}
				
					case(10):            	
	            	{
	            		END_GAME_CATWOMAN = 1;				// Displays CATWOMAN END GAME Screen
						return(1);
	            	}
				
					case(0):
					{
						return(0);
					}
	      		}
}
Function DUMB_AI()
{
    while(1)
	{
   		LASTPLACEDROW = RANDOM(0,2);
  		LASTPLACEDCOLUMN = RANDOM(0,2); 
    
 
		if (BOARD[LASTPLACEDROW][LASTPLACEDCOLUMN] = 0)
		{
  		SET_CELL_STATE(LASTPLACEDROW,LASTPLACEDCOLUMN);
		return;
  		}
	}
}

FUNCTION SMART_AI()
{
  					INTEGER I, X, Y;
            INTEGER NOT_CURRENTPLAYER;
  					NOT_CURRENTPLAYER = OLDPLAYER;
  					
            
            
            
            
            IF(BOARD[1][1] = 0)					//First checks to see if the middle is occupied. If it is not, piece will be put there
            {
              BOARD[1][1] = CURRENTPLAYER;
              LASTPLACEDROW = 1;
              LASTPLACEDCOLUMN = 1;
              RETURN;
            }
  
  					IF((BOARD[1][2] = NOT_CURRENTPLAYER) && (BOARD[2][1] = NOT_CURRENTPLAYER) && (BOARD[2][2] = 0))
            {
              BOARD[2][2] = CURRENTPLAYER;
              LASTPLACEDROW = 2;
              LASTPLACEDCOLUMN = 2;
              RETURN;
            }
              
			IF(IMPOSSIBLE_ACTIVE = 1)
            {
                  IF((BOARD[0][0] = CURRENTPLAYER) && (BOARD[0][1] = CURRENTPLAYE) && (BOARD[0][2] = NOT_CURRENTPLAYER) && (BOARD[1][0] = 0) && (BOARD[1][1] = NOT_CURRENTPLAYER) && (BOARD[1][2] = NOT_CURRENTPLAYER) && (BOARD[2][0] = CURRENTPLAYER) && (BOARD[2][1] = NOT_CURRENTPLAYER) && (BOARD[2][2] = 0))                        
                  {
                    BOARD[1][0] = CURRENTPLAYER;
                    LASTPLACEDROW = 1;
                    LASTPLACEDCOLUMN = 0;
                    RETURN;
                  }

                  IF((BOARD[0][0] = CURRENTPLAYER) && (BOARD[0][1] = 0) && (BOARD[0][2] = CURRENTPLAYER && (BOARD[1][0] = CURRENTPLAYER) && (BOARD[1][1] = NOT_CURRENTPLAYER) && (BOARD[1][2] = NOT_CURRENTPLAYER) && (BOARD[2][0] = NOT_CURRENTPLAYER) && (BOARD[2][1] = NOT_CURRENTPLAYER) && (BOARD[2][2] = 0)
                  {
                    BOARD[0][1] = 0CURRENTPLAYER;
                    LASTPLACEDROW = 0;
                    LASTPLACEDCOLUMN = 1;
                    RETURN;
                  }

            }
  
            FOR(I = 0 TO 2)				//LOOP THAT CHECKS EVERY ROW,COLUMN FOR 2 OF THE CURRENT PLAYER AND AN EMPTY SPACE. wILL PLACE PIECE IN EMPTY SPACE TO WIN THE GAME
            {
              IF((BOARD[I][0] = CURRENTPLAYER) && (BOARD[I][1] = CURRENTPLAYER) && (BOARD[I][2] = 0))
              {
                BOARD[I][2] = CURRENTPLAYER;
                LASTPLACEDROW = I;
                LASTPLACEDCOLUMN = 2; 
                RETURN;
              } 
              IF((BOARD[I][0] = CURRENTPLAYER) && (BOARD[I][1] = 0) && (BOARD[I][2] = CURRENTPLAYER))
              {
                BOARD[I][1] = CURRENTPLAYER;
                LASTPLACEDROW = I;
                LASTPLACEDCOLUMN = 1;
                RETURN;
              }
              IF((BOARD[I][0] = 0) && (BOARD[I][1] = CURRENTPLAYER) && (BOARD[I][2] = CURRENTPLAYER))
              {
                BOARD[I][0] = CURRENTPLAYER;
                LASTPLACEDROW = I;
                LASTPLACEDCOLUMN = 0;
                RETURN;
              }
                
                
              IF((BOARD[0][I] = CURRENTPLAYER) && (BOARD[1][I] = CURRENTPLAYER) && (BOARD[2][I] = 0))
              {
                BOARD[2][I] = CURRENTPLAYER;
                LASTPLACEDROW = 2;
                LASTPLACEDCOLUMN = I;
                RETURN;
              }
              IF((BOARD[0][I] = CURRENTPLAYER) && (BOARD[1][I] = 0) && (BOARD[2][I] = CURRENTPLAYER))
              {
                BOARD[1][I] = CURRENTPLAYER;
                LASTPLACEDROW = 1;
                LASTPLACEDCOLUMN = I;
                RETURN;
              }
              IF((BOARD[0][I] = 0) && (BOARD[1][I] = CURRENTPLAYER) && (BOARD[2][I] = CURRENTPLAYER))
              {
                BOARD[0][I] = CURRENTPLAYER;
                LASTPLACEDROW = 0;
                LASTPLACEDCOLUMN = I;
                RETURN;
              } 
              
            }
  
  
  
  
  
  					//Checking eack diagonal for 2 of the current player and an empty space
  
  					IF((BOARD[0][0] = CURRENTPLAYER) && (BOARD[1][1] = CURRENTPLAYER) && (BOARD[2][2] = 0))
            {
              BOARD[2][2] = CURRENTPLAYER;
              LASTPLACEDROW = 2;
              LASTPLACEDCOLUMN = 2;
              RETURN;
            }     
            IF((BOARD[0][0] = CURRENTPLAYER) && (BOARD[1][1] = 0) && (BOARD[2][2] = CURRENTPLAYER))
            {
              BOARD[1][1] = CURRENTPLAYER;
              LASTPLACEDROW = 1;
              LASTPLACEDCOLUMN = 1;
              RETURN;
            }   
            IF((BOARD[0][0] = 0) && (BOARD[1][1] = CURRENTPLAYER) && (BOARD[2][2] = CURRENTPLAYER))
            {
              BOARD[0][0] = CURRENTPLAYER;
              LASTPLACEDROW = 0;
              LASTPLACEDCOLUMN = 0;
              RETURN;
            }
              
            IF((BOARD[0][2] = CURRENTPLAYER) && (BOARD[1][1] = CURRENTPLAYER) && (BOARD[2][0] = 0))
            {
              BOARD[2][0] = CURRENTPLAYER;
              LASTPLACEDROW = 2;
              LASTPLACEDCOLUMN = 0;
              RETURN;
            }
            IF((BOARD[0][2] = CURRENTPLAYER) && (BOARD[1][1] = 0) && (BOARD[2][0] = CURRENTPLAYER))
            {
              BOARD[1][1] = CURRENTPLAYER;
              LASTPLACEDROW = 1; 
              LASTPLACEDCOLUMN = 1;
              RETURN;
            }  
            IF((BOARD[0][2] = 0) && (BOARD[1][1] = CURRENTPLAYER) && (BOARD[2][0] = CURRENTPLAYER))
            {
              BOARD[0][2] = CURRENTPLAYER;
              LASTPLACEDROW = 0;
              LASTPLACEDCOLUMN = 2;
              RETURN;
            }
  
  
  
  
  
  
  					I = 0;
              
            FOR(I = 0 TO 2)				//LOOP THAT CHECKS EVERY ROW,COLUMN FOR 2 OF THE OPPONENT PLAYER AND AN EMPTY SPACE. WILL PLACE PIECE IN EMPTY SPACE TO PREVENT OPPONENT FROM WINNING GAME
            {
              IF((BOARD[I][0] = NOT_CURRENTPLAYER) && (BOARD[I][1] = NOT_CURRENTPLAYER) && (BOARD[I][2] = 0))
              {
                BOARD[I][2] = CURRENTPLAYER;
                LASTPLACEDROW = I;
              	LASTPLACEDCOLUMN = 2;
                RETURN;
              }                
              IF((BOARD[I][0] = NOT_CURRENTPLAYER) && (BOARD[I][1] = 0) && (BOARD[I][2] = NOT_CURRENTPLAYER))
              {
                BOARD[I][1] = CURRENTPLAYER;
                LASTPLACEDROW = I;
              	LASTPLACEDCOLUMN = 1;
                RETURN;
              }
              IF((BOARD[I][0] = 0) && (BOARD[I][1] = NOT_CURRENTPLAYER) && (BOARD[I][2] = NOT_CURRENTPLAYER))
              {
                BOARD[I][0] = CURRENTPLAYER;
                LASTPLACEDROW = I;
              	LASTPLACEDCOLUMN = 0;
                RETURN;
              }

              IF((BOARD[0][I] = NOT_CURRENTPLAYER) && (BOARD[1][I] = NOT_CURRENTPLAYER) && (BOARD[2][I] = 0))
              {
                BOARD[2][I] = CURRENTPLAYER;
                LASTPLACEDROW = 2;
              	LASTPLACEDCOLUMN = I;
                RETURN;
              }
              IF((BOARD[0][I] = NOT_CURRENTPLAYER) && (BOARD[1][I] = 0) && (BOARD[2][I] = NOT_CURRENTPLAYER))
              {
              	BOARD[1][I] = CURRENTPLAYER;  
                LASTPLACEDROW = 1;
              	LASTPLACEDCOLUMN = I;
                RETURN;
              }
                
              IF((BOARD[0][I] = 0) && (BOARD[1][I] = NOT_CURRENTPLAYER) && (BOARD[2][I] = NOT_CURRENTPLAYER))
              {
                BOARD[0][I] = CURRENTPLAYER;
                LASTPLACEDROW = 0;
              	LASTPLACEDCOLUMN = I;
                RETURN;
              }
                
              
            }
  
  					IF((BOARD[0][0] = NOT_CURRENTPLAYER) && (BOARD[1][1] = NOT_CURRENTPLAYER) && (BOARD[2][2] = 0))
            {
              BOARD[2][2] = CURRENTPLAYER;
              LASTPLACEDROW = 2;
              LASTPLACEDCOLUMN = 2;
              RETURN;
            }  
            IF((BOARD[0][0] = NOT_CURRENTPLAYER) && (BOARD[1][1] = 0) && (BOARD[2][2] = NOT_CURRENTPLAYER))
            {
              BOARD[1][1] = CURRENTPLAYER;
              LASTPLACEDROW = 1;
              LASTPLACEDCOLUMN = 1;
              RETURN;
            }    
            IF((BOARD[0][0] = 0) && (BOARD[1][1] = NOT_CURRENTPLAYER) && (BOARD[2][2] = NOT_CURRENTPLAYER))
            {
              BOARD[0][0] = CURRENTPLAYER;
              LASTPLACEDROW = 0;
              LASTPLACEDCOLUMN = 0;
              RETURN;
            }
                
              
            IF((BOARD[0][2] = NOT_CURRENTPLAYER) && (BOARD[1][1] = NOT_CURRENTPLAYER) && (BOARD[2][0] = 0))
            {
              BOARD[2][0] = CURRENTPLAYER;
              LASTPLACEDROW = 2;
              LASTPLACEDCOLUMN = 0;
              RETURN;
            }  
            IF((BOARD[0][2] = NOT_CURRENTPLAYER) && (BOARD[1][1] = 0) && (BOARD[2][0] = NOT_CURRENTPLAYER))
            {
              BOARD[1][1] = CURRENTPLAYER;
              LASTPLACEDROW = 1;
              LASTPLACEDCOLUMN = 1;
              RETURN;
            } 
            IF((BOARD[0][2] = 0) && (BOARD[1][1] = NOT_CURRENTPLAYER) && (BOARD[2][0] = NOT_CURRENTPLAYER))
            {
              BOARD[0][2] = CURRENTPLAYER;
              LASTPLACEDROW = 0;
              LASTPLACEDCOLUMN = 2;
              RETURN;
            }
                
  					
  
  				I = 0;
  
            FOR(I = 0 TO 2)				//LOOP THAT CHECKS EVERY ROW,COLUMN FOR 2 OF THE CURRENT PLAYER AND AN EMPTY SPACE. wILL PLACE PIECE IN EMPTY SPACE TO WIN THE GAME
            {
              IF((BOARD[I][0] = CURRENTPLAYER) && (BOARD[I][1] = 0) && (BOARD[I][2] = 0))
              {
                BOARD[I][2] = CURRENTPLAYER;
                LASTPLACEDROW = I;
              	LASTPLACEDCOLUMN = 2;
                RETURN;
              }
              IF((BOARD[I][0] = 0) && (BOARD[I][1] = 0) && (BOARD[I][2] = CURRENTPLAYER)){
                BOARD[I][0] = CURRENTPLAYER;
                LASTPLACEDROW = I;
              	LASTPLACEDCOLUMN = 0;
                RETURN;
              } 
              IF((BOARD[I][0] = 0) && (BOARD[I][1] = CURRENTPLAYER) && (BOARD[I][2] = 0))
              {
                BOARD[I][0] = CURRENTPLAYER;
                LASTPLACEDROW = I;
              	LASTPLACEDCOLUMN = 0;
                RETURN;
              }
                
              IF((BOARD[0][I] = CURRENTPLAYER) && (BOARD[1][I] = 0) && (BOARD[2][I] = 0))
              {
                BOARD[2][I] = CURRENTPLAYER;
                LASTPLACEDROW = 2;
              	LASTPLACEDCOLUMN = I;
                RETURN;
              }
              IF((BOARD[0][I] = 0) && (BOARD[1][I] = 0) && (BOARD[2][I] = CURRENTPLAYER))
              {
                BOARD[0][I] = CURRENTPLAYER;
                LASTPLACEDROW = 0;
              	LASTPLACEDCOLUMN = I;
                RETURN;
              }
                
              IF((BOARD[0][I] = 0) && (BOARD[1][I] = CURRENTPLAYER) && (BOARD[2][I] = 0))
              {
                BOARD[0][I] = CURRENTPLAYER;
                LASTPLACEDROW = 0;
              	LASTPLACEDCOLUMN = I;
                RETURN;
              }
                
              
            }
  
  					IF((BOARD[0][0] = CURRENTPLAYER) && (BOARD[1][1] = 0) && (BOARD[2][2] = 0))
            {
              BOARD[2][2] = CURRENTPLAYER;
              LASTPLACEDROW = 2;
              LASTPLACEDCOLUMN = 2;
              RETURN;
            } 
            IF((BOARD[0][0] = 0) && (BOARD[1][1] = 0) && (BOARD[2][2] = CURRENTPLAYER))
            {
              BOARD[0][0] = CURRENTPLAYER;
              LASTPLACEDROW = 0;
              LASTPLACEDCOLUMN = 0;
              RETURN;
            }
            IF((BOARD[0][0] = 0) && (BOARD[1][1] = CURRENTPLAYER) && (BOARD[2][2] = 0))
            {
              BOARD[0][0] = CURRENTPLAYER;
              LASTPLACEDROW = 0;
              LASTPLACEDCOLUMN = 0;
              RETURN;
            }
                
            IF((BOARD[0][2] = CURRENTPLAYER) && (BOARD[1][1] = 0) && (BOARD[2][0] = 0))
            {
              BOARD[2][0] = CURRENTPLAYER;
              LASTPLACEDROW = 2;
              LASTPLACEDCOLUMN = 0;
              RETURN;
            }
            IF((BOARD[0][2] = 0) && (BOARD[1][1] = 0) && (BOARD[2][0] = CURRENTPLAYER))
            {
              BOARD[0][2] = CURRENTPLAYER;
              LASTPLACEDROW = 0;
              LASTPLACEDCOLUMN = 2;
              RETURN;
            }
                
            IF((BOARD[0][2] = 0) && (BOARD[1][1] = CURRENTPLAYER) && (BOARD[2][0] = 0))
            {
              BOARD[0][2] = CURRENTPLAYER;
              LASTPLACEDROW = 0;
              LASTPLACEDCOLUMN = 2;
              RETURN;
            }
              	
            
            
  					IF(BOARD[0][0] = 0)
            {
              BOARD[0][0] = CURRENTPLAYER;
              LASTPLACEDROW = 0;
              LASTPLACEDCOLUMN = 0;
              RETURN;
            }
  					IF(BOARD[0][2] = 0)
            {
              BOARD[0][2] = CURRENTPLAYER;
              LASTPLACEDROW = 0;
              LASTPLACEDCOLUMN = 2;
              RETURN;
            }
            IF(BOARD[2][0] = 0)
            {
              BOARD[2][0] = CURRENTPLAYER;
              LASTPLACEDROW = 2;
              LASTPLACEDCOLUMN = 0;
              RETURN;
            }
  					IF(BOARD[2][2] = 0)
            {
              BOARD[2][2] = CURRENTPLAYER;
              LASTPLACEDROW = 2;
              LASTPLACEDCOLUMN = 2;
              RETURN;
            }
  					
            X = RANDOM(0,2);
            Y = RANDOM(0,2);
            
  					BOARD[X][Y] = CURRENTPLAYER;
  					RETURN;
}

Function MEDIUM_AI()
{
    if(COUNTER % 2 = 1)
	{
		DUMB_AI();
		return;
	}
	
	if(COUNTER % 2 = 0)
	{
		SMART_AI();
		return;
	}
}
Function AI()
{
   	if(HOW_DIFFICULT = 0)
   	{
     	DUMB_AI();
   	}
  
	if(HOW_DIFFICULT = 1)
   	{
     	MEDIUM_AI();
   	}

	if(HOW_DIFFICULT = 2)
	{
		SMART_AI();
	}
}

/*******************************************************************************************
  Event Handlers
  (Uncomment and declare additional event handlers as needed)
*******************************************************************************************/
Threadsafe PUSH END_GAME
{
    	CLEAR_BOARD();
        UPDATE_BOARD();
       	RESET_COUNT();
}          

Threadsafe PUSH NEXT_GAME
{
        CLEAR_BOARD();
        UPDATE_BOARD();
}
Threadsafe PUSH SET_GRID
{
            integer i;
            i = GetLastModifiedArrayIndex();
            i = i - 1;
            LASTPLACEDCOLUMN = i % GRIDSIZE;
            LASTPLACEDROW = (i - LASTPLACEDCOLUMN) / GRIDSIZE;
            if (IMPOSSIBLE_ACTIVE = 1)
			{
				OLDPLAYER = 2;
			}
   
			if (GET_CELL_STATE(LASTPLACEDROW, LASTPLACEDCOLUMN) = 0)
			{
			
	      	SET_CELL_STATE(LASTPLACEDROW, LASTPLACEDCOLUMN);
	      	UPDATE_BOARD();
			
			if(FINAL_CHECK() = 0)
			{       	 
				SWITCHPLAYER();
              	if (HOW_MANY_PLAYERS = 1)
              	{
					COUNTER = COUNTER + 1;
              		AI();
					UPDATE_BOARD();
					FINAL_CHECK();
                  	SWITCHPLAYER();
              	}
			}
			}
}			

Threadsafe PUSH BATMAN_FIRST
{
		CURRENTPLAYER = 1;				// Current player is BATMAN
    	OLDPLAYER = 4;					// Old player is JOKER
    	CHOOSE_CHARACTER = 0;			// Mutes Choose Character Screen
}

Threadsafe PUSH JOKER_FIRST
{
		CURRENTPLAYER = 4;				// Current player is JOKER
    	OLDPLAYER = 1;					// Old player is BATMAN
    	CHOOSE_CHARACTER = 0;			// Mutes Choose Character Screen
}

Threadsafe PUSH ONE_PLAYERS
{
		HOW_MANY_PLAYERS = 1;			// Chooses 1 Player
      	CHOOSE_DIFFICULTY = 1;			// Displays Choose Difficulty Screen
      	CHOOSE_HOW_MANY = 0;			// Mutes How Many Players Screen
}

Threadsafe PUSH TWO_PLAYERS
{
		HOW_MANY_PLAYERS = 0;			// Chooses 2 Players
      	CHOOSE_DIFFICULTY = 0;			// Mutes Choose Difficulty Screen
		CHOOSE_HOW_MANY = 0;			// Mutes How Many Players Screen
}

Threadsafe PUSH EASY_GAME
{
		HOW_DIFFICULT = 0;				// Chooses Easy Game
      	CHOOSE_CHARACTER = 1;			// Displays Choose Character Screen
      	CHOOSE_DIFFICULTY = 0;			// Mutes Choose Difficulty Screen
}
 
Threadsafe PUSH MEDIUM_GAME
{
		HOW_DIFFICULT = 1;				// Chooses Medium Game
      	CHOOSE_CHARACTER = 1;			// Displays Choose Character Screen
      	CHOOSE_DIFFICULTY = 0;			// Mutes Choose Difficulty Screen

Threadsafe PUSH HARD_GAME
{
		HOW_DIFFICULT = 2;				// Choose Hard Game
      	CHOOSE_CHARACTER = 1;			// Displays Choose Character Screen
      	CHOOSE_DIFFICULTY = 0;			// Mutes Choose Difficulty Screen
}

Threadsafe PUSH IMPOSSIBLE_GAME
{
 		HOW_DIFFICULT = 2				// Chooses Hard Game
		IMPOSSIBLE_ACTIVE = 1;			// Initiates Impossible Game
      	CHOOSE_CHARACTER = 1;			// Displays Choose Character Screen
      	CHOOSE_DIFFICULTY = 0;			// Mutes Choose Difficulty Screen
}
/*******************************************************************************************
  Main()
  Uncomment and place one-time startup code here
  (This code will get called when the system starts up)
*******************************************************************************************/

Function Main()
{
        	CLEAR_BOARD();
         	UPDATE_BOARD();
       		RESET_COUNT();
			SEED(0);
}
